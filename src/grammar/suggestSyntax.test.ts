import { suggestSyntax, wordnetParse } from "./suggestSyntax";
import { PredicateSyntax } from "../PredicateSyntax";
import { allTenses } from "../util/tense";
import { deepCompare } from "../util/deepCompare";

describe.each([
  [{ verb: "live", params: ["subject", "in"] }, ["you", "a house"]],
  [{ verb: "chase", params: ["subject", "object"] }, ["the cat", "the dog"]],
  [
    { verb: "seduce", params: ["subject", "object", "under"] },
    ["the priest", "the pope", "a starry sky"],
  ],
  [{ verb: "eat", params: ["subject", "object"] }, ["the man", "the bean"]],
])(
  "Testing suggestSyntax with strings generated by %j",
  ({ verb, params }: any, args: string[]) => {
    const P = new PredicateSyntax(verb, params);
    const table = allTenses.map((tense) => [tense, P.str(args, { tense })]);

    test.each(table)(`%s: Determining syntax of "%s"`, async (tense, str) => {
      let foundMatch = false;
      let numberOfTrees = 0;
      for await (let suggestion of suggestSyntax(str)) {
        numberOfTrees++;
        if (suggestion.verb == verb && deepCompare(suggestion.params, params))
          foundMatch = true;
      }
      expect(numberOfTrees).toBe(1);
      expect(foundMatch).toBe(true);
    });
  }
);

test("Testing wordnetParse()", async () => {
  const forest = await wordnetParse("the man ate the bean");
  forest.assertNoDuplicateNonTerminalRules();
  forest.assertNoDuplicateRules();

  const [...trees] = forest.recursiveTrees();
  const strings = trees.map((tree: any) => forest.stringifyTree(tree));
  let counts: { [str: string]: number } = {};
  for (let str of strings) {
    if (counts[str]) counts[str]++;
    else counts[str] = 1;
  }
  console.log(counts, `total: ${strings.length}`);
});

test.todo("suggestSyntax for strings in question form");
test.todo("suggestSyntax for strings in negated form");
test.todo("suggestSyntax for strings in noun-phrase form");
